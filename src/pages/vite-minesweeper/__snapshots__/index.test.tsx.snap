// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ViteMinesweeperPage should show as expected 1`] = `
<main
  class="min-h-screen flex flex-col px-8 py-24 gap-16 sm:px-24 max-w-6xl"
>
  <div
    class="w-full text-right"
  >
    최근 수정 일자: 
    2024
    년 
    9
    월
     
    13
    일
  </div>
  <h1
    class="text-bold text-4xl sm:text-5xl md:text-6xl"
  >
    Vite 지뢰찾기 (ViteMinesweeper)
  </h1>
  <div
    class="w-full flex flex-row flex-wrap justify-center items-center"
  >
    <img
      alt="ViteMinesweeper Expert 단계 승리 장면"
      class="w-fit max-h-80 object-contain"
      data-nimg="1"
      decoding="async"
      height="40"
      loading="lazy"
      src="/_next/image?url=%2Fimg.jpg&w=96&q=75"
      srcset="/_next/image?url=%2Fimg.jpg&w=48&q=75 1x, /_next/image?url=%2Fimg.jpg&w=96&q=75 2x"
      style="color: transparent;"
      width="40"
    />
  </div>
  <section
    class="flex flex-col gap-8 undefined"
  >
    <h2
      class="text-bold text-2xl sm:text-3xl md:text-4xl"
    >
      개요
    </h2>
    <section>
      <ul
        class="list-disc pl-8"
      >
        <li>
          React와 너비 우선 탐색 알고리즘을 활용하여 만든 Microsoft Minesweeper 스타일 지뢰찾기.
        </li>
        <li>
          개인 프로젝트
        </li>
        <li>
          구현 내용 요약
          <ul
            class="list-disc pl-8"
          >
            <li>
              프로젝트 세팅, 최소 구현 조건 설정, 기능 구현, 테스트, 배포, 문서 및 업데이트 로그 작성, 유지보수를 담당함.
            </li>
            <li>
              지뢰찾기 게임, 재방문 후 이어서 하기 등등 각종 기능 구현.
            </li>
            <li>
              Vite + Yarn Berry로 프로젝트를 세팅하여 Create React App 대비 로딩 시간 30초 → 5초로 감소, 설치 속도가 5배 빨라짐.
            </li>
            <li>
              빈 타일 클릭 후 8방향 주변의 또다른 빈 타일을 탐색하기 위해 활용한 BFS 알고리즘에 쓰인 큐를 Array.prototype.shift() 기반에서 링크드 리스트 기반으로 변경하여, 큐의 pop 시간 복잡도를 O(n)에서 O(1)로 개선함.
            </li>
          </ul>
        </li>
      </ul>
    </section>
  </section>
  <section
    class="flex flex-col gap-8 undefined"
  >
    <h2
      class="text-bold text-2xl sm:text-3xl md:text-4xl"
    >
      방문하기
    </h2>
    <section>
      [
       
      <a
        class="text-blue-500 hover:text-purple-500 undefined"
        href="https://github.com/kuman514/ViteMinesweeper"
        target="_blank"
      >
        GitHub 저장소
      </a>
       
      ] [
       
      <a
        class="text-blue-500 hover:text-purple-500 undefined"
        href="https://vite-minesweeper.vercel.app/"
        target="_blank"
      >
        게임 플레이
      </a>
       
      ]
    </section>
  </section>
  <section
    class="flex flex-col gap-8 undefined"
  >
    <h2
      class="text-bold text-2xl sm:text-3xl md:text-4xl"
    >
      플레이 방법 (Windows Chrome 기준)
    </h2>
    <section>
      <ul
        class="list-disc pl-8"
      >
        <li>
          게임의 룰은 Microsoft Windows 7까지의 기본 게임이었던 Microsoft Minesweeper의 룰을 지향하고 있습니다.
        </li>
        <li>
          마우스 좌클릭으로 방문되지 않은 타일을 확인할 수 있습니다.
        </li>
        <li>
          마우스 우클릭으로 방문되지 않은 타일에 지뢰가 있다고 짐작하는 \`마킹\`을 남길 수 있습니다.
        </li>
        <li>
          마우스 양쪽 클릭으로 주변에 지뢰가 있는지 확인할 수 있습니다.
          <ul
            class="list-disc pl-8"
          >
            <li>
              숫자와 주변 마킹의 개수가 일치하지 않으면 작동하지 않습니다.
            </li>
          </ul>
        </li>
        <li>
          지뢰를 건드리거나 모두 찾으면 게임이 종료됩니다.
        </li>
        <li>
          <span
            class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
          >
            Reset
          </span>
           버튼으로 게임을 다시 시작할 수 있습니다.
        </li>
        <li>
          <span
            class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
          >
            Config
          </span>
           버튼으로 게임의 규격을 설정할 수 있습니다. 설정 시 진행 중인 게임은 초기화됩니다.
        </li>
        <li>
          게임에서 설정할 수 있는 규격의 범위입니다.
          <ul
            class="list-disc pl-8"
          >
            <li>
              너비: 9 ~ 30칸
            </li>
            <li>
              높이: 9 ~ 16칸
            </li>
            <li>
              지뢰 개수: 10 ~ Floor(너비 * 높이 * 0.925)개
            </li>
          </ul>
        </li>
      </ul>
    </section>
  </section>
  <section
    class="flex flex-col gap-8 undefined"
  >
    <h2
      class="text-bold text-2xl sm:text-3xl md:text-4xl"
    >
      사용한 기술 스택
    </h2>
    <section
      class="flex flex-row flex-wrap gap-2"
    >
      <span
        class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
      >
        React
      </span>
      <span
        class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
      >
        TypeScript
      </span>
      <span
        class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
      >
        Vite
      </span>
      <span
        class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
      >
        Yarn Berry
      </span>
      <span
        class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
      >
        Zustand
      </span>
      <span
        class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
      >
        Vercel
      </span>
      <span
        class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
      >
        ChakraUI
      </span>
    </section>
  </section>
  <section
    class="flex flex-col gap-8 undefined"
  >
    <h2
      class="text-bold text-2xl sm:text-3xl md:text-4xl"
    >
      지뢰찾기 구현에 쓰인 알고리즘
    </h2>
    <section
      class="flex flex-col gap-4"
    >
      <div
        class="flex justify-center items-center"
      >
        <img
          alt="ViteMinesweeper 구현에 쓰인 알고리즘인 BFS"
          data-nimg="1"
          decoding="async"
          height="40"
          loading="lazy"
          src="/_next/image?url=%2Fimg.jpg&w=96&q=75"
          srcset="/_next/image?url=%2Fimg.jpg&w=48&q=75 1x, /_next/image?url=%2Fimg.jpg&w=96&q=75 2x"
          style="color: transparent;"
          width="40"
        />
      </div>
      <p
        class="text-base font-normal indent-4 undefined"
      >
        지뢰찾기 게임에서, 어떤 타일을 눌렀을 때 또다른 숫자 타일이나 가장자리에 다다를 때까지
         
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          주변 8방향으로 빈 타일 탐색
        </strong>
        을 수행하는데, 여기서 가장 효율적인 방법인
         
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          BFS(너비 우선 탐색) 알고리즘
        </strong>
        을 적용하였습니다.
      </p>
    </section>
  </section>
  <section
    class="flex flex-col gap-8 undefined"
  >
    <h2
      class="text-bold text-2xl sm:text-3xl md:text-4xl"
    >
      큐의 Pop 호출 시간 복잡도 개선
    </h2>
    <section
      class="flex flex-col gap-4"
    >
      <p
        class="text-base font-normal indent-4 undefined"
      >
        앱 속도 개선 작업 이전에는,
         
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          사용자들로부터 앱의 반응이 약간 느리다는 피드백
        </strong>
        을 받았습니다. 그 원인 중 하나가, 
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          Array.prototype.shift()
        </span>
        를 큐의 pop에 사용하고 있었다는 점이었습니다. 실제로,
         
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          Array.prototype.shift()
        </span>
        는 배열의 맨 앞 원소 제거 후 나머지 원소의 인덱스가 전부 변경되므로, 한 번 실행할 때마다 배열의 길이만큼의 연산 시간을 가집니다. 즉, 시간복잡도가 
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          O(n)
        </span>
        이라는 이야기이죠.
      </p>
      <p
        class="text-base font-normal indent-4 undefined"
      >
        이를 개선하기 위해
         
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          시간복잡도가 
          <span
            class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
          >
            O(1)
          </span>
          인 pop 방법
        </strong>
        을 사용 해야 했는데, 그 방법이
         
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          링크드 리스트 기반의 pop을 사용하는 큐를 직접 만드는 것
        </strong>
        이었습니다. 링크드 리스트를 사용하면, 맨 앞 원소 
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          front
        </span>
        를 pop할 때 
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          front
        </span>
        만 그 뒤를 가리키게 만들고 이전에
         
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          front
        </span>
        였던걸 반환하기만 하면 됩니다. 이렇게
         
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          Array.prototype.shift()
        </span>
         기반의 pop을 사용하는 큐를 직접 구현한 링크드 리스트 큐로 교체함으로써,
         
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          앱의 속도를 개선
        </strong>
        했습니다.
      </p>
      <div
        class="flex justify-center items-center"
      >
        <img
          alt="Array.prototype.shift() 기반 pop과 링크드 리스트 기반 pop의 성능 비교"
          data-nimg="1"
          decoding="async"
          height="40"
          loading="lazy"
          src="/_next/image?url=%2Fimg.jpg&w=96&q=75"
          srcset="/_next/image?url=%2Fimg.jpg&w=48&q=75 1x, /_next/image?url=%2Fimg.jpg&w=96&q=75 2x"
          style="color: transparent;"
          width="40"
        />
      </div>
      <p
        class="text-base font-normal indent-4 undefined"
      >
        큐가 얼마나 잘 작동하는지 검증하는 수단으로,
         
        <a
          class="text-blue-500 hover:text-purple-500 undefined"
          href="https://www.acmicpc.net/"
          target="_blank"
        >
          백준
        </a>
        에서 큐를 사용하는 유형의 문제 풀이에 응용했습니다. (
        <a
          class="text-blue-500 hover:text-purple-500 undefined"
          href="https://www.acmicpc.net/problem/14940"
          target="_blank"
        >
          예시 문제
        </a>
        ) 81596705호 제출은 
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          Array.prototype.shift()
        </span>
         기반의 pop을 사용하고 있으며, 81596769호 제출은 링크드 리스트 기반의 pop을 사용하고 있습니다. 여기서, 
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          링크드 리스트를 사용했을 때
        </strong>
        가
         
        <span
          class="font-mono bg-gray-300 text-red-700 text-sm px-1 py-0.5 rounded undefined"
        >
          Array.prototype.shift()
        </span>
        를 사용했을 때보다
         
        <strong
          class="bg-emphasize-underline from-transparent from-70% to-green-500 dark:to-green-600 to-70% undefined"
        >
          44ms 더 빨라지는
        </strong>
        것을 알 수 있습니다.
      </p>
    </section>
  </section>
</main>
`;
